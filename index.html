<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tom Signature | The Gilded Emerald</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;1,400&display=swap');

        :root {
            --emerald-dark: #001a10;
            --emerald: #023020;
            --gold: #D4AF37;
            --gold-light: #F7E7CE;
            --glass: rgba(20, 20, 20, 0.4);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Playfair Display', serif;
            color: var(--gold-light);
            /* Prevent bounce on mobile */
            overscroll-behavior: none;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Overlay */
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.8) 100%);
            transition: background 1s ease;
        }

        /* Helper class for hiding UI elements */
        .ui-hidden {
            opacity: 0 !important;
            pointer-events: none;
            transform: translateY(-20px);
        }
        
        .immersive-mode {
            background: transparent !important;
        }

        header {
            text-align: center;
            margin-top: 20px;
            pointer-events: auto;
            transition: all 1.2s cubic-bezier(0.19, 1, 0.22, 1);
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 2.5rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--gold);
            margin: 0;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
            opacity: 0;
            animation: fadeDown 1.5s ease-out forwards 0.5s;
        }

        .subtitle {
            font-size: 0.9rem;
            letter-spacing: 0.2em;
            color: rgba(255,255,255,0.6);
            margin-top: 10px;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeDown 1.5s ease-out forwards 0.8s;
        }

        /* Controls - Default Desktop */
        .controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: flex-end;
            padding-bottom: 40px;
            pointer-events: auto;
            opacity: 0;
            animation: fadeUp 1.5s ease-out forwards 1.2s;
            flex-wrap: wrap; /* Allow wrap on smaller desktop windows */
        }

        .btn-group {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            transition: all 1s ease;
        }

        button, .file-btn {
            background: var(--glass);
            border: 1px solid var(--gold);
            color: var(--gold);
            padding: 15px 40px;
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            white-space: nowrap;
            /* Prevent zoom on double tap on mobile */
            touch-action: manipulation; 
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.4), transparent);
            transition: 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        button:hover {
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            transform: translateY(-2px);
        }

        button.active {
            background: var(--gold);
            color: var(--emerald-dark);
            box-shadow: 0 0 40px rgba(212, 175, 55, 0.6);
        }

        input[type="file"] {
            display: none;
        }

        /* --- Modal Styles --- */
        .custom-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .custom-modal.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-box {
            background: rgba(2, 48, 32, 0.95);
            border: 1px solid var(--gold);
            padding: 40px 60px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.2);
            transform: translateY(20px);
            transition: transform 0.5s ease;
            text-align: center;
            max-width: 90%;
            box-sizing: border-box;
        }

        .custom-modal.visible .modal-box {
            transform: translateY(0);
        }

        .modal-title {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .modal-input {
            background: transparent;
            border: none;
            border-bottom: 1px solid rgba(212, 175, 55, 0.5);
            color: var(--gold-light);
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            padding: 10px;
            width: 300px;
            max-width: 100%;
            text-align: center;
            outline: none;
            transition: border-color 0.3s;
        }

        .modal-input:focus {
            border-bottom-color: var(--gold);
        }

        .modal-actions {
            margin-top: 20px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--gold);
            font-family: 'Cinzel', serif;
            letter-spacing: 0.2em;
            font-size: 0.8rem;
            animation: pulse 2s infinite;
            text-align: center;
            width: 100%;
        }

        @keyframes fadeDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* --- MOBILE RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            #ui {
                padding: 20px;
                padding-bottom: 30px; /* Safe area */
            }

            h1 {
                font-size: 1.8rem; /* Smaller title */
                letter-spacing: 0.15em;
            }

            .subtitle {
                font-size: 0.75rem;
            }

            .controls {
                flex-direction: column; /* Stack vertically on mobile */
                width: 100%;
                gap: 12px;
                align-items: stretch; /* Full width buttons */
                padding-bottom: 20px;
            }

            .btn-group {
                width: 100%;
            }

            button {
                width: 100%; /* Full width */
                padding: 12px 0; /* Taller touch targets */
                font-size: 0.9rem;
            }

            /* Modal adjustments */
            .modal-box {
                padding: 30px 20px;
                width: 90%;
            }
            
            .modal-input {
                width: 100%;
                font-size: 1rem;
            }
        }
    </style>
    <!-- React & Three Imports -->
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
                "three": "https://esm.sh/three@0.160.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.12?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
                "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
                "uuid": "https://esm.sh/uuid@9.0.1"
            }
        }
    </script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <!-- Customize Text Modal -->
    <div id="text-modal" class="custom-modal">
        <div class="modal-box">
            <div class="modal-title">Personalize Experience</div>
            <input type="text" id="input-title" class="modal-input" placeholder="Enter Main Title">
            <input type="text" id="input-subtitle" class="modal-input" placeholder="Enter Subtitle">
            <div class="modal-actions">
                <button id="confirm-text-btn">Update Display</button>
            </div>
        </div>
    </div>

    <div id="ui">
        <header id="main-header">
            <h1 id="app-title">Christmas Tree</h1>
            <div id="app-subtitle" class="subtitle">The Gilded Emerald Edition</div>
        </header>
        <div class="controls">
            <div class="btn-group" id="group-music">
                <button onclick="document.getElementById('music-upload').click()">Load Music</button>
                <input type="file" id="music-upload" accept="audio/*">
            </div>
            <!-- New Customize Button -->
            <div class="btn-group" id="group-edit">
                <button id="edit-text-btn">Customize Text</button>
            </div>
            <div class="btn-group" id="group-action">
                <button id="toggle-state">Assemble Tree</button>
            </div>
        </div>
    </div>
    
    <div id="canvas-container">
        <div class="loading">Initializing Luxury Asset Pipeline...</div>
    </div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, useEffect, Suspense } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree, extend } from '@react-three/fiber';
        import { OrbitControls, Environment, Float, Sparkles, PerspectiveCamera, Stars } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise, ToneMapping } from '@react-three/postprocessing';

        // --- Audio Infrastructure ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        const dataArray = new Uint8Array(analyser.frequencyBinCount);
        
        let activeSourceNode = null; 
        
        const defaultAudioEl = new Audio('https://cdn.pixabay.com/audio/2025/05/26/audio_95504c3693.mp3');
        defaultAudioEl.crossOrigin = "anonymous";
        defaultAudioEl.loop = true;
        
        let defaultMediaElementSource = null;

        const useAudioData = () => {
            const frequency = useRef(0);
            useFrame(() => {
                analyser.getByteFrequencyData(dataArray);
                const avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
                frequency.current = avg; 
            });
            return frequency;
        };

        // --- Custom Shaders ---

        // 1. Foliage Shader (Needles)
        const foliageVertexShader = `
            uniform float uTime;
            uniform float uProgress; // 0 = Scattered, 1 = Tree
            uniform float uAudio;
            
            attribute vec3 aScatterPos;
            attribute vec3 aTreePos;
            attribute float aRandom;
            
            varying float vVisible;
            varying vec2 vUv;
            varying float vRandom;
            varying float vHeight;

            void main() {
                vUv = uv;
                vRandom = aRandom;
                
                // Interpolate positions
                vec3 finalPos = mix(aScatterPos, aTreePos, uProgress);
                
                // Add "breathing" effect based on audio
                float breathe = sin(uTime * 2.0 + aRandom * 10.0) * 0.05;
                float beat = uAudio * 0.02 * uProgress; // More movement when assembled
                
                finalPos += normal * (breathe + beat);
                
                // Add noise/wind in scatter mode
                if(uProgress < 0.5) {
                    finalPos.y += sin(uTime + aScatterPos.x) * 0.2 * (1.0 - uProgress);
                }

                vHeight = finalPos.y; // For gradient color

                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_PointSize = (4.0 * (1.0 + uAudio * 0.1)) * (20.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        // Fragment Shader for Rhythmic Color
        const foliageFragmentShader = `
            uniform float uTime;
            uniform float uAudio; // Audio intensity (0.0 to ~1.0)

            varying float vRandom;
            varying float vHeight;
            varying vec2 vUv;

            void main() {
                // Circular particle
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;

                // --- Color Palette ---
                vec3 emerald = vec3(0.0, 0.25, 0.18);   // Classic Deep Emerald
                vec3 ruby = vec3(0.3, 0.02, 0.05);      // Deep Festive Red
                vec3 gold = vec3(1.0, 0.9, 0.4);        // Champagne Gold

                // --- Rhythmic Logic ---
                // 1. Slow shift over time (Green <-> Red tint)
                float timeCycle = sin(uTime * 0.4) * 0.5 + 0.5; 
                vec3 baseTone = mix(emerald, ruby, timeCycle * 0.2); // subtle mix, mostly emerald

                // 2. Gradient based on height (darker bottom, lighter top)
                float heightFactor = smoothstep(-5.0, 8.0, vHeight);
                vec3 gradientBase = mix(baseTone * 0.5, baseTone * 1.8, heightFactor);

                // 3. Audio Beat Reactivity
                // If audio is loud (beat), shift towards Gold/Warmth
                float beatStrength = smoothstep(0.4, 0.9, uAudio); 
                vec3 rhythmicColor = mix(gradientBase, gold, beatStrength * 0.4);

                // --- Glitter/Sparkle Effect ---
                float sparkle = sin(uTime * 3.0 + vRandom * 100.0);
                float isTip = step(0.96, sin(vRandom * 30.0 + uTime + uAudio * 5.0)); // Random gold specs that react to audio
                
                vec3 finalColor = mix(rhythmicColor, gold * 2.5, isTip * (sparkle * 0.5 + 0.5 + beatStrength));
                
                // Soft edge glow
                float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                
                gl_FragColor = vec4(finalColor, alpha * 0.9);
            }
        `;

        // --- Components ---

        const Foliage = ({ isTree, count = 15000 }) => {
            const meshRef = useRef();
            const audioFreq = useAudioData();
            
            // Pre-calculate positions
            const uniforms = useMemo(() => ({
                uTime: { value: 0 },
                uProgress: { value: 0 },
                uAudio: { value: 0 }
            }), []);

            const [attributes] = useState(() => {
                const scatterPos = new Float32Array(count * 3);
                const treePos = new Float32Array(count * 3);
                const randoms = new Float32Array(count);

                const treeHeight = 12;
                const treeRadius = 4.5;

                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    
                    // 1. Scatter Position (Sphere of chaos)
                    const r = 15 * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    scatterPos[i3] = r * Math.sin(phi) * Math.cos(theta);
                    scatterPos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                    scatterPos[i3+2] = r * Math.cos(phi);

                    // 2. Tree Position (Cone)
                    // Spiral distribution for better coverage
                    const y = Math.random() * treeHeight; // 0 to 12
                    const normalizedY = y / treeHeight; // 0 to 1 (bottom to top)
                    const currentRadius = (1.0 - normalizedY) * treeRadius;
                    const angle = i * 0.1; // Spiral
                    
                    // Add some noise to tree shape so it's not perfect
                    const noise = (Math.random() - 0.5) * 0.5;
                    
                    treePos[i3] = (currentRadius + noise) * Math.cos(angle);
                    treePos[i3+1] = y - 4; // Shift down to center
                    treePos[i3+2] = (currentRadius + noise) * Math.sin(angle);

                    randoms[i] = Math.random();
                }
                return { scatterPos, treePos, randoms };
            });

            useFrame((state, delta) => {
                if (meshRef.current) {
                    meshRef.current.material.uniforms.uTime.value += delta;
                    
                    // Smooth transition for state
                    const targetProgress = isTree ? 1.0 : 0.0;
                    meshRef.current.material.uniforms.uProgress.value = THREE.MathUtils.lerp(
                        meshRef.current.material.uniforms.uProgress.value,
                        targetProgress,
                        delta * 1.5
                    );

                    // Audio reactivity - pass normalized audio to shader
                    const normalizedAudio = Math.min(audioFreq.current / 128.0, 1.0); // Normalize 0-255 to roughly 0-2 range for intensity
                    meshRef.current.material.uniforms.uAudio.value = THREE.MathUtils.lerp(
                        meshRef.current.material.uniforms.uAudio.value,
                        normalizedAudio,
                        0.2 // faster reaction
                    );
                    
                    meshRef.current.rotation.y += 0.001;
                }
            });

            return (
                <points ref={meshRef}>
                    <bufferGeometry>
                        <bufferAttribute attach="attributes-position" count={count} array={attributes.scatterPos} itemSize={3} />
                        <bufferAttribute attach="attributes-aScatterPos" count={count} array={attributes.scatterPos} itemSize={3} />
                        <bufferAttribute attach="attributes-aTreePos" count={count} array={attributes.treePos} itemSize={3} />
                        <bufferAttribute attach="attributes-aRandom" count={count} array={attributes.randoms} itemSize={1} />
                    </bufferGeometry>
                    <shaderMaterial
                        vertexShader={foliageVertexShader}
                        fragmentShader={foliageFragmentShader}
                        uniforms={uniforms}
                        transparent={true}
                        depthWrite={false}
                        blending={THREE.AdditiveBlending}
                    />
                </points>
            );
        };

        const Ornaments = ({ isTree, count = 200, type = "sphere", color = "#D4AF37", scale = 0.3 }) => {
            const meshRef = useRef();
            const audioFreq = useAudioData();
            
            const [data] = useState(() => {
                const arr = [];
                const treeHeight = 11;
                const treeRadius = 4;
                
                for (let i = 0; i < count; i++) {
                    // Scatter Pos
                    const r = 12 * Math.cbrt(Math.random());
                    const theta = Math.random() * 2 * Math.PI;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const sx = r * Math.sin(phi) * Math.cos(theta);
                    const sy = r * Math.sin(phi) * Math.sin(theta);
                    const sz = r * Math.cos(phi);

                    // Tree Pos
                    const y = Math.random() * treeHeight;
                    const nY = y / treeHeight;
                    const cR = (1.0 - nY) * treeRadius; // Outer surface
                    const ang = Math.random() * Math.PI * 2;
                    
                    const tx = cR * Math.cos(ang);
                    const ty = y - 4;
                    const tz = cR * Math.sin(ang);

                    arr.push({ scatter: new THREE.Vector3(sx, sy, sz), tree: new THREE.Vector3(tx, ty, tz) });
                }
                return arr;
            });

            const dummy = useMemo(() => new THREE.Object3D(), []);

            useFrame((state, delta) => {
                if (!meshRef.current) return;

                const t = state.clock.elapsedTime;
                const target = isTree ? 1 : 0;
                
                meshRef.current.userData.progress = THREE.MathUtils.lerp(
                    meshRef.current.userData.progress || 0,
                    target,
                    delta * 1.2
                );
                
                const p = meshRef.current.userData.progress;
                const audioScale = 1 + (audioFreq.current / 255) * 0.3;

                data.forEach((item, i) => {
                    const { scatter, tree } = item;
                    dummy.position.lerpVectors(scatter, tree, p);
                    
                    dummy.position.y += Math.sin(t + i) * 0.02 * (1-p); 
                    
                    // Scale effect on beat
                    dummy.scale.setScalar(scale * (i % 2 === 0 ? audioScale : 1));
                    
                    dummy.rotation.x = t * 0.2 + i;
                    dummy.rotation.z = t * 0.1 + i;
                    
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
            });

            const geometry = type === 'box' ? new THREE.BoxGeometry(1, 1, 1) : new THREE.SphereGeometry(1, 16, 16);

            return (
                <instancedMesh ref={meshRef} args={[geometry, null, count]}>
                    <meshStandardMaterial 
                        color={color} 
                        roughness={0.1} 
                        metalness={0.9} 
                        emissive={color}
                        emissiveIntensity={0.2}
                    />
                </instancedMesh>
            );
        };

        const StarTopper = ({ isTree }) => {
            const ref = useRef();

            // Create Star Geometry using Shape
            const starGeometry = useMemo(() => {
                const shape = new THREE.Shape();
                const points = 5;
                const outerRadius = 0.8;
                const innerRadius = 0.4;
                
                // Adjust starting angle to point upwards (Math.PI / 2 points index 0 straight UP)
                const angleOffset = Math.PI / 2; 

                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points + angleOffset;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    if (i === 0) shape.moveTo(x, y);
                    else shape.lineTo(x, y);
                }
                shape.closePath();

                const extrudeSettings = {
                    depth: 0.2,
                    bevelEnabled: true,
                    bevelThickness: 0.1,
                    bevelSize: 0.05,
                    bevelSegments: 3
                };

                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                
                // CRITICAL FIX: Only center Z axis to keep pivot correct
                geometry.computeBoundingBox();
                const zCenter = (geometry.boundingBox.max.z - geometry.boundingBox.min.z) / 2;
                geometry.translate(0, 0, -zCenter); // Center Z only
                
                return geometry;
            }, []);
            
            useFrame((state, delta) => {
                if(ref.current) {
                    // Tweaked targetY from 8 to 9 to offset it upwards by approx half its size (0.8 radius)
                    const targetY = isTree ? 9 : 15; // Top of tree vs floating high
                    const targetScale = isTree ? 1 : 0.1;
                    
                    ref.current.position.y = THREE.MathUtils.lerp(ref.current.position.y, targetY, delta * 2);
                    ref.current.scale.setScalar(THREE.MathUtils.lerp(ref.current.scale.x, targetScale, delta * 2));
                    ref.current.rotation.y += delta;
                }
            });

            return (
                <group ref={ref} position={[0, 15, 0]}>
                    <mesh geometry={starGeometry}>
                        <meshStandardMaterial color="#FFD700" emissive="#FFD700" emissiveIntensity={2} toneMapped={false} />
                    </mesh>
                    <pointLight color="#FFD700" intensity={5} distance={10} decay={2} />
                </group>
            );
        };

        // --- Responsive Camera Controller ---
        const ResponsiveCamera = () => {
            const { camera, size } = useThree();
            
            useEffect(() => {
                const isMobilePortrait = size.width < 768 && size.width < size.height;
                
                // If mobile portrait, pull camera back to fit the tree vertically
                const targetZ = isMobilePortrait ? 35 : 20; 
                
                camera.position.z = targetZ;
                camera.updateProjectionMatrix();
                
            }, [size.width, size.height, camera]);

            return null;
        };

        const Scene = ({ isTree }) => {
            return (
                <>
                    <PerspectiveCamera makeDefault position={[0, 4, 20]} fov={50} />
                    <ResponsiveCamera /> {/* Handle Mobile Resize */}
                    
                    <OrbitControls 
                        enablePan={false} 
                        minDistance={10} 
                        maxDistance={50} 
                        maxPolarAngle={Math.PI / 1.5} 
                        autoRotate={true}
                        autoRotateSpeed={0.5}
                    />

                    {/* Lighting - Lobby Style */}
                    <Environment preset="city" blur={1} background={false} />
                    <ambientLight intensity={0.2} color="#002b16" />
                    <spotLight position={[10, 20, 10]} angle={0.3} penumbra={1} intensity={2} castShadow color="#F7E7CE" />
                    <spotLight position={[-10, 5, 10]} angle={0.5} penumbra={1} intensity={1} color="#023020" />
                    
                    {/* The Gilded Elements */}
                    <Foliage isTree={isTree} />
                    
                    {/* Heavy Ornaments (Gifts/Boxes) - Metallic Red/Gold */}
                    <Ornaments isTree={isTree} count={60} type="box" color="#8B0000" scale={0.4} />
                    
                    {/* Light Ornaments (Balls) - Pure Gold */}
                    <Ornaments isTree={isTree} count={120} type="sphere" color="#D4AF37" scale={0.25} />
                    
                    {/* Tiny Lights - Warm White */}
                    <Ornaments isTree={isTree} count={300} type="sphere" color="#FFFDD0" scale={0.05} />

                    <StarTopper isTree={isTree} />

                    {/* Atmospheric Particles */}
                    <Sparkles count={200} scale={12} size={2} speed={0.4} opacity={0.5} color="#F7E7CE" />
                </>
            );
        };

        const PostProcessingEffects = () => {
            return (
                <EffectComposer disableNormalPass>
                    {/* Bloom for that Gilded Look */}
                    <Bloom 
                        luminanceThreshold={0.8} 
                        mipmapBlur 
                        intensity={1.2} 
                        radius={0.6}
                    />
                    <ToneMapping />
                    <Vignette eskil={false} offset={0.1} darkness={1.1} />
                    <Noise opacity={0.02} /> 
                </EffectComposer>
            );
        };

        const App = () => {
            const [isTree, setIsTree] = useState(false);
            const [audioReady, setAudioReady] = useState(false);

            // --- Separate Effect for Audio Initialization (Streaming) ---
            useEffect(() => {
                const fileInput = document.getElementById('music-upload');
                
                // Helper to unlock context
                const resumeContext = () => {
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                };

                // 1. Initialize Default Music (Streaming mode)
                const startDefaultMusic = () => {
                    // Create MediaElementSource only once to avoid errors
                    if (!defaultMediaElementSource) {
                        try {
                            defaultMediaElementSource = audioContext.createMediaElementSource(defaultAudioEl);
                            defaultMediaElementSource.connect(analyser);
                            analyser.connect(audioContext.destination);
                            activeSourceNode = defaultMediaElementSource;
                        } catch(e) {
                            console.log("Audio node already created or error", e);
                        }
                    }
                    
                    // Try to play immediately
                    defaultAudioEl.play().then(() => {
                        console.log("Auto-playing");
                        setAudioReady(true);
                        const btn = document.querySelector('#group-music button');
                        if(btn) { btn.innerText = "Playing Default..."; btn.classList.add('active'); }
                    }).catch(e => {
                        console.log("Autoplay blocked, waiting for interaction");
                        // Add silent listener to document to unlock on first click
                        const unlockAndPlay = () => {
                            resumeContext();
                            defaultAudioEl.play();
                            setAudioReady(true);
                            const btn = document.querySelector('#group-music button');
                            if(btn) { btn.innerText = "Playing Default..."; btn.classList.add('active'); }
                            document.removeEventListener('click', unlockAndPlay);
                            document.removeEventListener('touchstart', unlockAndPlay);
                        };
                        document.addEventListener('click', unlockAndPlay);
                        document.addEventListener('touchstart', unlockAndPlay);
                    });
                };

                startDefaultMusic(); // Start immediately

                // 2. Handle User Upload (Buffer mode)
                const handleFile = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        // Stop default streaming
                        defaultAudioEl.pause();
                        
                        // Stop previous active buffer source if any
                        if (activeSourceNode && activeSourceNode.stop) {
                            try { activeSourceNode.stop(); } catch(e){}
                        }

                        const reader = new FileReader();
                        reader.onload = (ev) => {
                            audioContext.decodeAudioData(ev.target.result, (buffer) => {
                                const source = audioContext.createBufferSource();
                                source.buffer = buffer;
                                source.connect(analyser);
                                
                                source.loop = true;
                                source.start(0);
                                activeSourceNode = source;
                                
                                setAudioReady(true);
                                document.querySelector('#group-music button').innerText = "Playing Custom...";
                                document.querySelector('#group-music button').classList.add('active');
                            });
                        };
                        reader.readAsArrayBuffer(file);
                    }
                };

                fileInput.addEventListener('change', handleFile);

                // Modal & UI Logic
                const editBtn = document.getElementById('edit-text-btn');
                const modal = document.getElementById('text-modal');
                const confirmBtn = document.getElementById('confirm-text-btn');

                const openModal = () => {
                    document.getElementById('input-title').value = document.getElementById('app-title').innerText;
                    document.getElementById('input-subtitle').value = document.getElementById('app-subtitle').innerText;
                    modal.classList.add('visible');
                };
                const closeModal = () => modal.classList.remove('visible');
                const updateText = () => {
                    const newTitle = document.getElementById('input-title').value;
                    const newSubtitle = document.getElementById('input-subtitle').value;
                    if(newTitle) document.getElementById('app-title').innerText = newTitle;
                    if(newSubtitle) document.getElementById('app-subtitle').innerText = newSubtitle;
                    closeModal();
                };

                editBtn.addEventListener('click', openModal);
                confirmBtn.addEventListener('click', updateText);
                const modalClick = (e) => { if (e.target === modal) closeModal(); };
                modal.addEventListener('click', modalClick);

                return () => {
                    fileInput.removeEventListener('change', handleFile);
                    editBtn.removeEventListener('click', openModal);
                    confirmBtn.removeEventListener('click', updateText);
                    modal.removeEventListener('click', modalClick);
                };
            }, []); 

            // --- Effect for UI State Management ---
            useEffect(() => {
                const toggleBtn = document.getElementById('toggle-state');
                const header = document.getElementById('main-header');
                const musicGroup = document.getElementById('group-music');
                const editGroup = document.getElementById('group-edit');
                const uiContainer = document.getElementById('ui');

                if (isTree) {
                    header.classList.add('ui-hidden');
                    musicGroup.classList.add('ui-hidden');
                    editGroup.classList.add('ui-hidden');
                    uiContainer.classList.add('immersive-mode');
                    toggleBtn.innerText = "Scatter Elements";
                } else {
                    header.classList.remove('ui-hidden');
                    musicGroup.classList.remove('ui-hidden');
                    editGroup.classList.remove('ui-hidden');
                    uiContainer.classList.remove('immersive-mode');
                    toggleBtn.innerText = "Assemble Tree";
                }

                const handleToggle = () => {
                    setIsTree(prev => !prev);
                    if (audioContext.state === 'suspended') audioContext.resume();
                };

                toggleBtn.onclick = handleToggle; 
                return () => { toggleBtn.onclick = null; };
            }, [isTree]);

            return (
                <Canvas 
                    shadows 
                    dpr={[1, 2]} 
                    gl={{ antialias: false, toneMappingExposure: 1.5 }}
                >
                    <color attach="background" args={['#000500']} />
                    <Suspense fallback={null}>
                        <Scene isTree={isTree} />
                        <PostProcessingEffects />
                    </Suspense>
                </Canvas>
            );
        };

        const root = createRoot(document.getElementById('canvas-container'));
        root.render(<App />);
    </script>
</body>
</html>
